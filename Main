import pandas as pd
import numpy as np
import talib as tb
import pandas_ta as ta
from backtester import BackTester

def process_data(data):
    """
    Process the input data and return a dataframe with all the necessary indicators and data for making signalss.

    Parameters:
    data (pandas.DataFrame): The input data to be processed.

    Returns:
    pandas.DataFrame: The processed dataframe with all the necessary indicators and data.
    """
    # Generate the necessary indicators here
    
    # ATR for risk management
    data['ATR'] = ta.atr(data['high'], data['low'], data['close'], length=14)
    
    # Trend indicators - Moving Averages
    data['MA_10'] = ta.sma(data['close'], length=10)
    data['MA_30'] = ta.sma(data['close'], length=30)
    
    # Momentum indicator - RSI
    data['RSI'] = ta.rsi(data['close'], length=14)
    
    # Volume indicator - OBV (On-Balance Volume)
    data['OBV'] = ta.obv(data['close'], data['volume'])
    
    # Calculate OBV moving average for trend confirmation
    data['OBV_MA'] = ta.sma(data['OBV'], length=10)
    
    # Additional helper columns for divergence detection
    data['price_higher_high'] = False
    data['price_lower_low'] = False
    data['obv_higher_high'] = False
    data['obv_lower_low'] = False
    
    return data


def strat(data):
    """
    Create a strategy based on indicators or other factors.

    Parameters:
    - data: DataFrame
        The input data containing the necessary columns for strategy creation.

    Returns:
    - DataFrame
        The modified input data with an additional 'signals' column representing the strategy signals.
    """
    data['trade_type'] = "HOLD" 
    data['signals'] = 0
    position = 0  # Variable to keep track of the current position (0 = no position, 1 = long, -1 = short)
    entry_price = 0
    stop_loss_pct = 0.05  # 5% stop loss
    
    # Variables for divergence detection
    lookback_period = 20
    
    for i in range(max(30, lookback_period), len(data)):  # Starting from 30th index to ensure all indicators are calculated
        
        current_price = data.loc[i, 'close']
        ma_10 = data.loc[i, 'MA_10']
        ma_30 = data.loc[i, 'MA_30']
        rsi = data.loc[i, 'RSI']
        obv = data.loc[i, 'OBV']
        obv_ma = data.loc[i, 'OBV_MA']
        
        # Skip if any indicator is NaN
        if pd.isna(ma_10) or pd.isna(ma_30) or pd.isna(rsi) or pd.isna(obv) or pd.isna(obv_ma):
            continue
            
        # Detect price and OBV highs/lows for divergence analysis
        if i >= lookback_period:
            # Check for higher highs and lower lows in price
            price_window = data.loc[i-lookback_period:i, 'close']
            obv_window = data.loc[i-lookback_period:i, 'OBV']
            
            if current_price == price_window.max():
                data.loc[i, 'price_higher_high'] = True
            if current_price == price_window.min():
                data.loc[i, 'price_lower_low'] = True
            if obv == obv_window.max():
                data.loc[i, 'obv_higher_high'] = True
            if obv == obv_window.min():
                data.loc[i, 'obv_lower_low'] = True
        
        # Define trend conditions
        bullish_trend = ma_10 > ma_30  # MA crossover bullish
        bearish_trend = ma_10 < ma_30  # MA crossover bearish
        
        # Define momentum conditions
        rsi_oversold = rsi < 30
        rsi_overbought = rsi > 70
        rsi_neutral_bullish = 30 <= rsi <= 50
        rsi_neutral_bearish = 50 <= rsi <= 70
        
        # Define volume conditions
        obv_bullish = obv > obv_ma  # OBV above its moving average
        obv_bearish = obv < obv_ma  # OBV below its moving average
        
        # Detect divergences
        negative_divergence = (data.loc[i, 'price_higher_high'] and 
                             not data.loc[i, 'obv_higher_high'] and 
                             i > 0 and data.loc[i-1:i, 'obv_higher_high'].any())
        
        positive_divergence = (data.loc[i, 'price_lower_low'] and 
                             not data.loc[i, 'obv_lower_low'] and 
                             i > 0 and data.loc[i-1:i, 'obv_lower_low'].any())
        
        if position == 0:  # No position
            # LONG ENTRY CONDITIONS
            # Primary: MA bullish crossover + RSI conditions + OBV confirmation
            long_entry = (bullish_trend and 
                         (rsi_oversold or rsi_neutral_bullish) and 
                         obv_bullish and
                         not negative_divergence)
            
            # Additional long entry on positive divergence
            long_entry_divergence = (positive_divergence and rsi < 50)
            
            if long_entry or long_entry_divergence:
                data.loc[i, 'signals'] = 1  # Buy signal
                position = 1
                entry_price = current_price
                data.loc[i, 'trade_type'] = "LONG"
            
            # SHORT ENTRY CONDITIONS
            # Primary: MA bearish crossover + RSI conditions + OBV confirmation
            short_entry = (bearish_trend and 
                          (rsi_overbought or rsi_neutral_bearish) and 
                          obv_bearish and
                          not positive_divergence)
            
            # Additional short entry on negative divergence
            short_entry_divergence = (negative_divergence and rsi > 50)
            
            if short_entry or short_entry_divergence:
                data.loc[i, 'signals'] = -1  # Sell signal
                position = -1
                entry_price = current_price
                data.loc[i, 'trade_type'] = "SHORT"
        
        elif position == 1:  # Long position
            # Calculate stop loss
            stop_loss_price = entry_price * (1 - stop_loss_pct)
            
            # EXIT CONDITIONS for LONG
            # 1. Stop loss hit
            if current_price <= stop_loss_price:
                data.loc[i, 'signals'] = -1
                position = 0
                entry_price = 0
                data.loc[i, 'trade_type'] = "STOP_LOSS"
            
            # 2. Trend reversal + momentum confirmation
            elif (bearish_trend and rsi_overbought and obv_bearish):
                data.loc[i, 'signals'] = -1
                position = 0
                entry_price = 0
                data.loc[i, 'trade_type'] = "TREND_REVERSAL"
            
            # 3. Negative divergence detected
            elif negative_divergence:
                data.loc[i, 'signals'] = -1
                position = 0
                entry_price = 0
                data.loc[i, 'trade_type'] = "DIVERGENCE_EXIT"
            
            # 4. RSI overbought + bearish volume
            elif rsi_overbought and obv_bearish:
                data.loc[i, 'signals'] = -1
                position = 0
                entry_price = 0
                data.loc[i, 'trade_type'] = "MOMENTUM_EXIT"
        
        elif position == -1:  # Short position
            # Calculate stop loss
            stop_loss_price = entry_price * (1 + stop_loss_pct)
            
            # EXIT CONDITIONS for SHORT
            # 1. Stop loss hit
            if current_price >= stop_loss_price:
                data.loc[i, 'signals'] = 1
                position = 0
                entry_price = 0
                data.loc[i, 'trade_type'] = "STOP_LOSS"
            
            # 2. Trend reversal + momentum confirmation
            elif (bullish_trend and rsi_oversold and obv_bullish):
                data.loc[i, 'signals'] = 1
                position = 0
                entry_price = 0
                data.loc[i, 'trade_type'] = "TREND_REVERSAL"
            
            # 3. Positive divergence detected
            elif positive_divergence:
                data.loc[i, 'signals'] = 1
                position = 0
                entry_price = 0
                data.loc[i, 'trade_type'] = "DIVERGENCE_EXIT"
            
            # 4. RSI oversold + bullish volume
            elif rsi_oversold and obv_bullish:
                data.loc[i, 'signals'] = 1
                position = 0
                entry_price = 0
                data.loc[i, 'trade_type'] = "MOMENTUM_EXIT"
    
    return data

def main():
    data = pd.read_csv("BTC_2019_2023_1d.csv")
    processed_data = process_data(data) # process the data
    result_data = strat(processed_data) # Apply the strategy
    csv_file_path = "final_data.csv" 
    result_data.to_csv(csv_file_path, index=False)

    bt = BackTester("BTC", signal_data_path="final_data.csv", master_file_path="final_data.csv", compound_flag=1)
    bt.get_trades(1000)

    # print trades and their PnL
    for trade in bt.trades: 
        print(trade)
        print(trade.pnl())

    # Print results
    stats = bt.get_statistics()
    for key, val in stats.items():
        print(key, ":", val)


    #Check for lookahead bias
    print("Checking for lookahead bias...")
    lookahead_bias = False
    for i in range(len(result_data)):
        if result_data.loc[i, 'signals'] != 0:  # If there's a signal
            temp_data = data.iloc[:i+1].copy()  # Take data only up to that point
            temp_data = process_data(temp_data) # process the data
            temp_data = strat(temp_data) # Re-run strategy
            if temp_data.loc[i, 'signals'] != result_data.loc[i, 'signals']:
                print(f"Lookahead bias detected at index {i}")
                lookahead_bias = True

    if not lookahead_bias:
        print("No lookahead bias detected.")

    # Generate the PnL graph
    bt.make_trade_graph()
    bt.make_pnl_graph()
    
if __name__ == "__main__":
    main()
